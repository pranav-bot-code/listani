<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Tier List Maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <style>
        .tier-row {
            min-height: 120px;
        }

        .item-card {
            transition: transform 0.2s;
        }

        .item-card:hover {
            transform: scale(1.05);
        }

        .drag-over {
            background-color: rgba(59, 130, 246, 0.1);
            border: 2px dashed #3b82f6;
        }

        .dragging {
            opacity: 0.5;
        }

        /* Prevent image dragging interference */
        .item-card img {
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* Selection styles */
        .item-card.selected {
            ring: 2px;
            ring-color: #3b82f6;
            ring-offset: 2px;
            transform: scale(1.02);
        }

        .selection-checkbox {
            position: absolute;
            top: 2px;
            left: 2px;
            z-index: 10;
        }

        /* Dark mode toggle switch styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #3b82f6;
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        /* Tier stats */
        .tier-stats {
            font-size: 0.7rem;
            background: rgba(0, 0, 0, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
            margin-top: 2px;
        }
    </style>
</head>

<body class="bg-gray-100 dark:bg-gray-900 min-h-screen transition-colors duration-300">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="text-center mb-8">
            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center space-x-2">
                    <!-- Feature 1: Undo/Redo -->
                    <button onclick="undo()" disabled id="undoBtn" title="Undo (Ctrl+Z)"
                        class="px-3 py-1 bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 disabled:cursor-not-allowed text-white rounded text-sm transition-colors">
                        ‚Ü∂ Undo
                    </button>
                    <button onclick="redo()" disabled id="redoBtn" title="Redo (Ctrl+Y)"
                        class="px-3 py-1 bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 disabled:cursor-not-allowed text-white rounded text-sm transition-colors">
                        ‚Ü∑ Redo
                    </button>
                </div>
                <h1 class="text-4xl font-bold text-gray-800 dark:text-gray-100">Anime Tier List Maker</h1>
                <!-- Dark Mode Toggle -->
                <div class="flex items-center space-x-2">
                    <span class="text-sm text-gray-600 dark:text-gray-400">üåû</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
                        <span class="slider"></span>
                    </label>
                    <span class="text-sm text-gray-600 dark:text-gray-400">üåô</span>
                </div>
            </div>
            <p class="text-gray-600 dark:text-gray-400">Create your own anime tier list with data from AniList</p>
        </div>

        <!-- Controls Section -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-6 transition-colors duration-300">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Fetch Lists Section -->
                <div>
                    <h3 class="text-lg font-semibold mb-4 text-gray-800 dark:text-gray-200">Fetch Anime List</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">AniList
                                Username</label>
                            <div class="flex gap-2">
                                <input type="text" id="anilistUsername"
                                    class="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                                    placeholder="Enter AniList username">
                                <button onclick="fetchAniList()"
                                    class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors">
                                    Fetch
                                </button>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Status
                                Filter</label>
                            <select id="anilistStatusFilter"
                                class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
                                <option value="all">All Statuses</option>
                                <option value="COMPLETED">Completed</option>
                                <option value="CURRENT">Currently Watching</option>
                                <option value="PAUSED">Paused</option>
                                <option value="DROPPED">Dropped</option>
                                <option value="PLANNING">Planning</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Tier Management -->
                <div>
                    <h3 class="text-lg font-semibold mb-4 text-gray-800 dark:text-gray-200">Tier Management</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Add New
                                Tier</label>
                            <div class="flex gap-2">
                                <input type="text" id="newTierName"
                                    class="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                                    placeholder="Tier name (e.g., S, A, B...)">
                                <input type="color" id="newTierColor" value="#3b82f6"
                                    class="w-12 h-10 border border-gray-300 dark:border-gray-600 rounded-md">
                                <button onclick="addTier()"
                                    class="px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-md transition-colors">
                                    Add
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="downloadScreenshot()"
                                class="px-4 py-2 bg-gray-800 hover:bg-gray-900 dark:bg-gray-600 dark:hover:bg-gray-700 text-white rounded-md transition-colors">
                                üì∏ Screenshot
                            </button>
                            <button onclick="clearAll()"
                                class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-md transition-colors">
                                Clear All
                            </button>
                            <!-- Feature 5: Import/Export -->
                            <button onclick="exportTierList()"
                                class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-md transition-colors">
                                üíæ Export
                            </button>
                            <label
                                class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors cursor-pointer text-center">
                                üìÅ Import
                                <input type="file" accept=".json" onchange="importTierList(event)" class="hidden">
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Feature 2: Bulk Selection Controls -->
            <div id="bulkControls"
                class="hidden mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
                <div class="flex items-center justify-between">
                    <span class="text-sm font-medium text-blue-800 dark:text-blue-200">
                        <span id="selectedCount">0</span> anime selected
                    </span>
                    <div class="flex gap-2">
                        <select id="bulkMoveTarget"
                            class="px-2 py-1 text-sm border rounded bg-white dark:bg-gray-700 dark:border-gray-600">
                            <option value="">Move to tier...</option>
                        </select>
                        <button onclick="moveSelectedAnime()"
                            class="px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded text-sm">
                            Move Selected
                        </button>
                        <button onclick="clearSelection()"
                            class="px-3 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded text-sm">
                            Clear Selection
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading indicator -->
            <div id="loadingIndicator" class="hidden mt-4 text-center">
                <div class="inline-flex items-center">
                    <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
                    <span class="ml-2 text-gray-700 dark:text-gray-300" id="loadingText">Loading anime data...</span>
                </div>
            </div>
        </div>

        <!-- Tier List Container -->
        <div id="tierListContainer"
            class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-6 transition-colors duration-300">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200">Tier List</h3>
                <!-- Feature 3: Auto-Sort -->
                <div class="flex gap-2">
                    <button onclick="toggleSelectionMode()"
                        class="px-3 py-1 bg-indigo-500 hover:bg-indigo-600 text-white rounded text-sm transition-colors">
                        üìã Select Mode
                    </button>
                    <select id="sortOption"
                        class="px-2 py-1 text-sm border rounded bg-white dark:bg-gray-700 dark:border-gray-600">
                        <option value="">Auto-sort tier by...</option>
                        <option value="score-desc">Score (High to Low)</option>
                        <option value="score-asc">Score (Low to High)</option>
                        <option value="title-asc">Title (A to Z)</option>
                        <option value="title-desc">Title (Z to A)</option>
                    </select>
                    <button onclick="autoSortTier()"
                        class="px-3 py-1 bg-orange-500 hover:bg-orange-600 text-white rounded text-sm">
                        Sort
                    </button>
                </div>
            </div>
            <div id="tierList">
                <!-- Default tiers -->
                <div class="tier-row flex border-b border-gray-200 dark:border-gray-700 mb-2" data-tier="S">
                    <div class="w-32 flex flex-col items-center justify-center font-bold text-white text-xl p-2"
                        style="background-color: #ef4444;">
                        <div>S</div>
                        <div class="tier-stats text-white" id="stats-S">0 items</div>
                    </div>
                    <div class="flex-1 min-h-full p-4 drop-zone flex flex-wrap gap-2 items-start" ondrop="drop(event)"
                        ondragover="allowDrop(event)" ondragleave="dragLeave(event)"></div>
                    <button onclick="removeTier('S')"
                        class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full m-2 transition-colors">√ó</button>
                </div>
                <div class="tier-row flex border-b border-gray-200 dark:border-gray-700 mb-2" data-tier="A">
                    <div class="w-32 flex flex-col items-center justify-center font-bold text-white text-xl p-2"
                        style="background-color: #f97316;">
                        <div>A</div>
                        <div class="tier-stats text-white" id="stats-A">0 items</div>
                    </div>
                    <div class="flex-1 min-h-full p-4 drop-zone flex flex-wrap gap-2 items-start" ondrop="drop(event)"
                        ondragover="allowDrop(event)" ondragleave="dragLeave(event)"></div>
                    <button onclick="removeTier('A')"
                        class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full m-2 transition-colors">√ó</button>
                </div>
                <div class="tier-row flex border-b border-gray-200 dark:border-gray-700 mb-2" data-tier="B">
                    <div class="w-32 flex flex-col items-center justify-center font-bold text-white text-xl p-2"
                        style="background-color: #eab308;">
                        <div>B</div>
                        <div class="tier-stats text-white" id="stats-B">0 items</div>
                    </div>
                    <div class="flex-1 min-h-full p-4 drop-zone flex flex-wrap gap-2 items-start" ondrop="drop(event)"
                        ondragover="allowDrop(event)" ondragleave="dragLeave(event)"></div>
                    <button onclick="removeTier('B')"
                        class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full m-2 transition-colors">√ó</button>
                </div>
                <div class="tier-row flex border-b border-gray-200 dark:border-gray-700 mb-2" data-tier="C">
                    <div class="w-32 flex flex-col items-center justify-center font-bold text-white text-xl p-2"
                        style="background-color: #22c55e;">
                        <div>C</div>
                        <div class="tier-stats text-white" id="stats-C">0 items</div>
                    </div>
                    <div class="flex-1 min-h-full p-4 drop-zone flex flex-wrap gap-2 items-start" ondrop="drop(event)"
                        ondragover="allowDrop(event)" ondragleave="dragLeave(event)"></div>
                    <button onclick="removeTier('C')"
                        class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full m-2 transition-colors">√ó</button>
                </div>
                <div class="tier-row flex border-b border-gray-200 dark:border-gray-700 mb-2" data-tier="D">
                    <div class="w-32 flex flex-col items-center justify-center font-bold text-white text-xl p-2"
                        style="background-color: #6366f1;">
                        <div>D</div>
                        <div class="tier-stats text-white" id="stats-D">0 items</div>
                    </div>
                    <div class="flex-1 min-h-full p-4 drop-zone flex flex-wrap gap-2 items-start" ondrop="drop(event)"
                        ondragover="allowDrop(event)" ondragleave="dragLeave(event)"></div>
                    <button onclick="removeTier('D')"
                        class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full m-2 transition-colors">√ó</button>
                </div>
            </div>
        </div>

        <!-- Anime Pool -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
            <h3 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">
                Anime Pool
                <span id="animeCount" class="text-sm text-gray-500 dark:text-gray-400 font-normal">(0 items)</span>
            </h3>
            <!-- Search bar -->
            <div class="mb-4">
                <input type="text" id="searchAnime" placeholder="Search anime in pool..."
                    class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                    oninput="searchAnime()">
            </div>
            <div id="animePool"
                class="drop-zone min-h-32 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-4 flex flex-wrap gap-4"
                ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
                <p class="text-gray-500 dark:text-gray-400 w-full text-center">Fetched anime will appear here. Drag them
                    to tiers above.</p>
            </div>
        </div>
    </div>

    <script>
        let animeData = [];
        let tierCounter = 0;

        // Feature 1: Undo/Redo System
        let history = [];
        let historyIndex = -1;
        let maxHistorySize = 50;
        let selectionMode = false;
        let selectedAnime = new Set();

        // Save state for undo/redo
        function saveState() {
            const state = {
                tierList: document.getElementById('tierList').innerHTML,
                animePool: document.getElementById('animePool').innerHTML,
                animeData: JSON.parse(JSON.stringify(animeData))
            };

            // Remove any states after current index (when user makes new action after undo)
            history = history.slice(0, historyIndex + 1);
            history.push(state);

            // Limit history size
            if (history.length > maxHistorySize) {
                history.shift();
            } else {
                historyIndex++;
            }

            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function restoreState(state) {
            document.getElementById('tierList').innerHTML = state.tierList;
            document.getElementById('animePool').innerHTML = state.animePool;
            animeData = JSON.parse(JSON.stringify(state.animeData));

            // Reattach event listeners
            attachDragListeners();
            updateTierStats();
            updateAnimeCount();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        // Feature 2: Bulk Selection
        function toggleSelectionMode() {
            selectionMode = !selectionMode;
            const cards = document.querySelectorAll('.item-card');
            const bulkControls = document.getElementById('bulkControls');

            if (selectionMode) {
                cards.forEach(card => addSelectionCheckbox(card));
                bulkControls.classList.remove('hidden');
                updateBulkMoveOptions();
            } else {
                cards.forEach(card => removeSelectionCheckbox(card));
                bulkControls.classList.add('hidden');
                clearSelection();
            }
        }

        function addSelectionCheckbox(card) {
            if (card.querySelector('.selection-checkbox')) return;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'selection-checkbox';
            checkbox.onchange = function (e) {
                e.stopPropagation();
                toggleAnimeSelection(card.id, this.checked);
            };
            card.appendChild(checkbox);
        }

        function removeSelectionCheckbox(card) {
            const checkbox = card.querySelector('.selection-checkbox');
            if (checkbox) checkbox.remove();
        }

        function toggleAnimeSelection(animeId, selected) {
            const card = document.getElementById(animeId);
            if (selected) {
                selectedAnime.add(animeId);
                card.classList.add('selected');
            } else {
                selectedAnime.delete(animeId);
                card.classList.remove('selected');
            }
            updateSelectedCount();
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = selectedAnime.size;
        }

        function updateBulkMoveOptions() {
            const select = document.getElementById('bulkMoveTarget');
            select.innerHTML = '<option value="">Move to tier...</option>';
            select.innerHTML += '<option value="pool">Anime Pool</option>';

            document.querySelectorAll('[data-tier]').forEach(tier => {
                const tierName = tier.getAttribute('data-tier');
                select.innerHTML += `<option value="${tierName}">${tierName}</option>`;
            });
        }

        function moveSelectedAnime() {
            const target = document.getElementById('bulkMoveTarget').value;
            if (!target || selectedAnime.size === 0) return;

            saveState();

            const targetElement = target === 'pool' ?
                document.getElementById('animePool') :
                document.querySelector(`[data-tier="${target}"] .drop-zone`);

            selectedAnime.forEach(animeId => {
                const card = document.getElementById(animeId);
                if (card) targetElement.appendChild(card);
            });

            clearSelection();
            updateTierStats();
            updateAnimeCount();
        }

        function clearSelection() {
            selectedAnime.clear();
            document.querySelectorAll('.item-card.selected').forEach(card => {
                card.classList.remove('selected');
                const checkbox = card.querySelector('.selection-checkbox');
                if (checkbox) checkbox.checked = false;
            });
            updateSelectedCount();
        }

        // Feature 3: Auto-Sort within Tiers
        function autoSortTier() {
            const sortOption = document.getElementById('sortOption').value;
            if (!sortOption) return;

            // Find which tier has selected anime or ask user
            let targetTier = null;
            if (selectedAnime.size > 0) {
                const firstSelected = document.getElementById([...selectedAnime][0]);
                targetTier = firstSelected.closest('[data-tier]')?.getAttribute('data-tier');
            }

            if (!targetTier) {
                targetTier = prompt('Which tier would you like to sort? (S, A, B, C, D, or custom tier name)');
                if (!targetTier) return;
            }

            const tierElement = document.querySelector(`[data-tier="${targetTier}"] .drop-zone`);
            if (!tierElement) return;

            saveState();

            const cards = Array.from(tierElement.querySelectorAll('.item-card'));

            cards.sort((a, b) => {
                const animeA = animeData.find(anime => anime.id === a.id);
                const animeB = animeData.find(anime => anime.id === b.id);

                switch (sortOption) {
                    case 'score-desc':
                        return (animeB.score || 0) - (animeA.score || 0);
                    case 'score-asc':
                        return (animeA.score || 0) - (animeB.score || 0);
                    case 'title-asc':
                        return animeA.title.localeCompare(animeB.title);
                    case 'title-desc':
                        return animeB.title.localeCompare(animeA.title);
                    default:
                        return 0;
                }
            });

            // Re-append in sorted order
            cards.forEach(card => tierElement.appendChild(card));

            document.getElementById('sortOption').value = '';
        }

        // Feature 4: Tier Statistics
        function updateTierStats() {
            document.querySelectorAll('[data-tier]').forEach(tierRow => {
                const tierName = tierRow.getAttribute('data-tier');
                const cards = tierRow.querySelectorAll('.item-card');
                const count = cards.length;

                let avgScore = 0;
                if (count > 0) {
                    const scores = Array.from(cards).map(card => {
                        const anime = animeData.find(a => a.id === card.id);
                        return anime?.score || 0;
                    }).filter(score => score > 0);

                    if (scores.length > 0) {
                        avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
                    }
                }

                const statsElement = document.getElementById(`stats-${tierName}`);
                if (statsElement) {
                    statsElement.textContent = count > 0 ?
                        `${count} items${avgScore > 0 ? ` ‚Ä¢ ${avgScore.toFixed(1)}‚òÖ` : ''}` :
                        '0 items';
                }
            });
        }

        // Feature 5: Import/Export
        function exportTierList() {
            const tierData = {};

            // Get anime from each tier
            document.querySelectorAll('[data-tier]').forEach(tierRow => {
                const tierName = tierRow.getAttribute('data-tier');
                const cards = tierRow.querySelectorAll('.item-card');
                tierData[tierName] = Array.from(cards).map(card => card.id);
            });

            // Get anime from pool
            const poolCards = document.getElementById('animePool').querySelectorAll('.item-card');
            tierData['pool'] = Array.from(poolCards).map(card => card.id);

            const exportData = {
                tiers: tierData,
                animeData: animeData,
                tierColors: getTierColors(),
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `anime-tierlist-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        function getTierColors() {
            const colors = {};
            document.querySelectorAll('[data-tier]').forEach(tierRow => {
                const tierName = tierRow.getAttribute('data-tier');
                const colorElement = tierRow.querySelector('[style*="background-color"]');
                if (colorElement) {
                    colors[tierName] = colorElement.style.backgroundColor;
                }
            });
            return colors;
        }

        function importTierList(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    if (confirm('This will replace your current tier list. Continue?')) {
                        saveState();

                        // Clear current stuff (pool & tiers only, keep tier headers)
                        document.getElementById('animePool').innerHTML = '';
                        document.querySelectorAll('.drop-zone').forEach(zone => {
                            if (zone.id !== 'animePool') zone.innerHTML = '';
                        });

                        animeData = importData.animeData || [];

                        // Recreate default tiers if needed
                        if (importData.tierColors) {
                            Object.keys(importData.tiers).forEach(tierName => {
                                if (tierName !== 'pool' && !document.querySelector(`[data-tier="${tierName}"]`)) {
                                    // make a new tier
                                    const tierList = document.getElementById("tierList");
                                    const tierRow = document.createElement("div");
                                    tierRow.className = "tier-row flex border-b border-gray-200 dark:border-gray-700 mb-2";
                                    tierRow.setAttribute("data-tier", tierName);

                                    const color = importData.tierColors[tierName] || "#3b82f6"; // fallback blue

                                    tierRow.innerHTML = `
                                <div class="w-32 flex flex-col items-center justify-center font-bold text-white text-xl p-2" 
                                     style="background-color: ${color};">
                                    <div>${tierName}</div>
                                    <div class="tier-stats text-white" id="stats-${tierName}">0 items</div>
                                </div>
                                <div class="flex-1 min-h-full p-4 drop-zone flex flex-wrap gap-2 items-start" 
                                     ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)"></div>
                                <button onclick="removeTier('${tierName}')" 
                                        class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full m-2 transition-colors">√ó</button>
                            `;
                                    tierList.appendChild(tierRow);
                                }
                            });
                        }

                        // Recreate anime cards in pool first
                        animeData.forEach(anime => {
                            const card = createAnimeCard(anime);
                            document.getElementById('animePool').appendChild(card);
                        });

                        // Move anime into their tiers
                        Object.entries(importData.tiers || {}).forEach(([tierName, animeIds]) => {
                            if (tierName === 'pool') return;
                            const tierElement = document.querySelector(`[data-tier="${tierName}"] .drop-zone`);
                            if (tierElement) {
                                animeIds.forEach(animeId => {
                                    const card = document.getElementById(animeId);
                                    if (card) tierElement.appendChild(card);
                                });
                            }
                        });

                        updateTierStats();
                        updateAnimeCount();
                        attachDragListeners();

                        alert('Tier list imported successfully!');
                    }
                } catch (error) {
                    alert('Error importing file: ' + error.message);
                }
            };
            reader.readAsText(file);

            event.target.value = ''; // reset file input
        }


        // Search functionality
        function searchAnime() {
            const searchTerm = document.getElementById('searchAnime').value.toLowerCase();
            const poolCards = document.getElementById('animePool').querySelectorAll('.item-card');

            poolCards.forEach(card => {
                const anime = animeData.find(a => a.id === card.id);
                const matches = anime && anime.title.toLowerCase().includes(searchTerm);
                card.style.display = matches ? 'block' : 'none';
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'z':
                        e.preventDefault();
                        undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                }
            }
        });

        // Rest of the existing code remains the same...

        // Dark mode functions
        function toggleDarkMode() {
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', isDark);
        }

        function initDarkMode() {
            const savedDarkMode = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedDarkMode === 'true' || (savedDarkMode === null && prefersDark)) {
                document.documentElement.classList.add('dark');
                document.getElementById('darkModeToggle').checked = true;
            }
        }

        // Drag and Drop Functions
        function allowDrop(ev) {
            ev.preventDefault();
            ev.currentTarget.classList.add('drag-over');
        }

        function dragLeave(ev) {
            if (!ev.currentTarget.contains(ev.relatedTarget)) {
                ev.currentTarget.classList.remove('drag-over');
            }
        }

        function drag(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
            ev.target.classList.add('dragging');
        }

        function drop(ev) {
            ev.preventDefault();
            ev.currentTarget.classList.remove('drag-over');

            const data = ev.dataTransfer.getData("text");
            const draggedElement = document.getElementById(data);

            if (draggedElement) {
                saveState();
                draggedElement.classList.remove('dragging');
                ev.currentTarget.appendChild(draggedElement);
                updateAnimeCount();
                updateTierStats();
            }
        }

        function attachDragListeners() {
            document.querySelectorAll('.item-card').forEach(card => {
                card.draggable = true;
                card.addEventListener('dragstart', drag);
                card.addEventListener('dragend', function (ev) {
                    ev.target.classList.remove('dragging');
                });

                if (selectionMode) {
                    addSelectionCheckbox(card);
                }
            });
        }

        // AniList API Functions
        async function fetchAniList() {
            const username = document.getElementById('anilistUsername').value.trim();
            const statusFilter = document.getElementById('anilistStatusFilter').value;

            if (!username) {
                alert('Please enter an AniList username');
                return;
            }

            showLoading(true, 'Fetching AniList data...');

            const query = `
                query ($username: String) {
                    MediaListCollection(userName: $username, type: ANIME) {
                        lists {
                            entries {
                                media {
                                    id
                                    title {
                                        romaji
                                        english
                                    }
                                    coverImage {
                                        large
                                        medium
                                    }
                                    format
                                    status
                                    episodes
                                    meanScore
                                }
                                score
                                status
                            }
                        }
                    }
                }
            `;

            try {
                const response = await fetch('https://graphql.anilist.co', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: query,
                        variables: { username: username }
                    })
                });

                const data = await response.json();

                if (data.errors) {
                    throw new Error(data.errors[0].message);
                }

                const animeList = [];
                data.data.MediaListCollection.lists.forEach(list => {
                    list.entries.forEach(entry => {
                        if (statusFilter === 'all' || entry.status === statusFilter) {
                            animeList.push({
                                id: `anilist_${entry.media.id}`,
                                title: entry.media.title.english || entry.media.title.romaji,
                                image: entry.media.coverImage.large || entry.media.coverImage.medium,
                                score: entry.score,
                                meanScore: entry.media.meanScore,
                                status: entry.status,
                                source: 'anilist'
                            });
                        }
                    });
                });

                saveState();
                displayAnime(animeList);
                showLoading(false);

                if (animeList.length === 0) {
                    alert(`No anime found with the selected status filter for user ${username}`);
                } else {
                    alert(`Successfully fetched ${animeList.length} anime from ${username}'s list`);
                }

            } catch (error) {
                console.error('Error fetching AniList data:', error);
                alert('Error fetching AniList data: ' + error.message);
                showLoading(false);
            }
        }

        function displayAnime(animeList) {
            const pool = document.getElementById('animePool');

            if (pool.children.length === 1 && pool.children[0].tagName === 'P') {
                pool.innerHTML = '';
            }

            let addedCount = 0;
            animeList.forEach(anime => {
                if (!document.getElementById(anime.id)) {
                    const animeCard = createAnimeCard(anime);
                    pool.appendChild(animeCard);
                    animeData.push(anime);
                    addedCount++;
                }
            });

            updateAnimeCount();

            if (addedCount === 0 && animeList.length > 0) {
                alert('All anime from this list are already added');
            }
        }

        function createAnimeCard(anime) {
            const card = document.createElement('div');
            card.id = anime.id;
            card.className = 'item-card relative bg-white dark:bg-gray-700 rounded-lg shadow-md overflow-hidden cursor-move transition-colors duration-300';
            card.draggable = true;
            card.style.width = '100px';
            card.style.height = '140px';

            card.addEventListener('dragstart', drag);
            card.addEventListener('dragend', function (ev) {
                ev.target.classList.remove('dragging');
            });

            const scoreDisplay = anime.score > 0 ? `${anime.score}/10` : 'N/A';

            card.innerHTML = `
                <img src="${anime.image}" alt="${anime.title}" 
                     class="w-full h-20 object-cover" 
                     onerror="this.src='https://via.placeholder.com/100x80?text=No+Image'">
                <div class="p-1">
                    <p class="text-xs font-medium truncate text-gray-900 dark:text-gray-100" title="${anime.title}">${anime.title}</p>
                    <p class="text-xs text-gray-500 dark:text-gray-400">${scoreDisplay}</p>
                </div>
                <button onclick="removeAnime('${anime.id}'); event.stopPropagation();" 
                        class="absolute top-1 right-1 w-5 h-5 bg-red-500 hover:bg-red-600 text-white rounded-full text-xs flex items-center justify-center transition-colors">√ó</button>
            `;

            if (selectionMode) {
                addSelectionCheckbox(card);
            }

            return card;
        }

        function updateAnimeCount() {
            const count = document.getElementById('animePool').children.length;
            const isPlaceholder = count === 1 && document.getElementById('animePool').children[0].tagName === 'P';
            const actualCount = isPlaceholder ? 0 : count;
            document.getElementById('animeCount').textContent = `(${actualCount} items)`;
        }

        function addTier() {
            const tierName = document.getElementById('newTierName').value.trim();
            const tierColor = document.getElementById('newTierColor').value;

            if (!tierName) {
                alert('Please enter a tier name');
                return;
            }

            if (document.querySelector(`[data-tier="${tierName}"]`)) {
                alert('Tier already exists');
                return;
            }

            saveState();

            const tierList = document.getElementById('tierList');
            const tierRow = document.createElement('div');
            tierRow.className = 'tier-row flex border-b border-gray-200 dark:border-gray-700 mb-2';
            tierRow.setAttribute('data-tier', tierName);

            tierRow.innerHTML = `
                <div class="w-32 flex flex-col items-center justify-center font-bold text-white text-xl p-2" 
                     style="background-color: ${tierColor};">
                    <div>${tierName}</div>
                    <div class="tier-stats text-white" id="stats-${tierName}">0 items</div>
                </div>
                <div class="flex-1 min-h-full p-4 drop-zone flex flex-wrap gap-2 items-start" 
                     ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)"></div>
                <button onclick="removeTier('${tierName}')" 
                        class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full m-2 transition-colors">√ó</button>
            `;

            tierList.appendChild(tierRow);
            updateBulkMoveOptions();
            document.getElementById('newTierName').value = '';
        }

        function removeTier(tierName) {
            if (confirm(`Are you sure you want to remove tier "${tierName}"?`)) {
                saveState();

                const tierRow = document.querySelector(`[data-tier="${tierName}"]`);
                if (tierRow) {
                    const items = tierRow.querySelectorAll('.item-card');
                    const pool = document.getElementById('animePool');

                    if (pool.children.length === 1 && pool.children[0].tagName === 'P') {
                        pool.innerHTML = '';
                    }

                    items.forEach(item => pool.appendChild(item));
                    tierRow.remove();
                    updateAnimeCount();
                    updateTierStats();
                    updateBulkMoveOptions();
                }
            }
        }

        function removeAnime(animeId) {
            if (confirm('Are you sure you want to remove this anime?')) {
                saveState();

                const element = document.getElementById(animeId);
                if (element) {
                    element.remove();
                    animeData = animeData.filter(anime => anime.id !== animeId);
                    selectedAnime.delete(animeId);
                    updateAnimeCount();
                    updateTierStats();
                    updateSelectedCount();

                    const pool = document.getElementById('animePool');
                    if (pool.children.length === 0) {
                        pool.innerHTML = '<p class="text-gray-500 dark:text-gray-400 w-full text-center">Fetched anime will appear here. Drag them to tiers above.</p>';
                        updateAnimeCount();
                    }
                }
            }
        }

        function showLoading(show, message = 'Loading...') {
            const indicator = document.getElementById('loadingIndicator');
            const text = document.getElementById('loadingText');

            if (show) {
                text.textContent = message;
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all anime and reset tiers?')) {
                saveState();

                document.getElementById('animePool').innerHTML = '<p class="text-gray-500 dark:text-gray-400 w-full text-center">Fetched anime will appear here. Drag them to tiers above.</p>';

                document.querySelectorAll('.drop-zone').forEach(zone => {
                    if (zone.id !== 'animePool') {
                        zone.innerHTML = '';
                    }
                });

                animeData = [];
                selectedAnime.clear();
                updateAnimeCount();
                updateTierStats();
                updateSelectedCount();
            }
        }

        async function downloadScreenshot() {
            const tierListContainer = document.getElementById('tierListContainer');

            try {
                showLoading(true, 'Generating high-quality screenshot...');

                const isDarkMode = document.documentElement.classList.contains('dark');
                let tempLightMode = false;

                // Offer light mode screenshot for better visibility
                if (isDarkMode) {
                    const useLightMode = confirm('Generate screenshot in light mode? (Cancel for dark mode)');
                    if (useLightMode) {
                        document.documentElement.classList.remove('dark');
                        tempLightMode = true;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                // Hide unwanted UI in screenshot
                const sortControls = tierListContainer.querySelectorAll('#sortOption, button[onclick="autoSortTier()"]');
                sortControls.forEach(el => el.style.display = 'none');

                // Temporarily keep only covers
                const originalContents = new Map();
                tierListContainer.querySelectorAll('.item-card').forEach(card => {
                    originalContents.set(card, card.innerHTML);

                    const img = card.querySelector('img');
                    card.innerHTML = '';
                    if (img) {
                        const clonedImg = img.cloneNode(true);
                        clonedImg.style.height = '100%';
                        clonedImg.style.width = '100%';
                        clonedImg.style.objectFit = 'cover';
                        card.appendChild(clonedImg);
                    }
                });

                // Take screenshot
                const rect = tierListContainer.getBoundingClientRect();
                const canvas = await html2canvas(tierListContainer, {
                    backgroundColor: isDarkMode && !tempLightMode ? '#1f2937' : '#ffffff',
                    scale: 2,
                    useCORS: true,
                    scrollX: 0,
                    scrollY: 0,
                    width: rect.width,
                    height: rect.height
                });

                // Restore original card content
                originalContents.forEach((html, card) => {
                    card.innerHTML = html;
                });

                // Show UI controls again
                sortControls.forEach(el => el.style.display = '');

                if (tempLightMode) {
                    document.documentElement.classList.add('dark');
                }

                // Download image
                const link = document.createElement('a');
                const mode = isDarkMode && !tempLightMode ? 'dark' : 'light';
                link.download = `anime-tierlist-${mode}-${new Date().toISOString().split('T')[0]}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();

                showLoading(false);
            } catch (error) {
                console.error('Error generating screenshot:', error);
                alert('Error generating screenshot. Please try again.');
                showLoading(false);
            }
        }


        // Initialize
        document.addEventListener('DOMContentLoaded', function () {
            initDarkMode();
            updateAnimeCount();
            updateTierStats();
            saveState(); // Initial state
        });
    </script>
</body>

</html>